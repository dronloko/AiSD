/*
============================================================================
 Name        : The next element
 Author      : Andrey Polyansky
 Version     : 1.0
 Copyright   : All rights reserved
 Description : Quest 4
============================================================================
*/

#include <iostream>
#include <algorithm>

using std::cout;
using std::cin;
using std::endl;

// Двоичный поиск в массиве А минимального индекcа минимального элемента массива,
// не меньшего x. Поиск производится c индекса low до индекса high включительно.
int Binary_Search(int *A, int low, int high, int x) {
    int mid = low + (high - low)/2;  // Опорный элемент - середина
    // Значение меньше минимального в массиве - возвращаем индекс первого элемента
    if ( x <= A[low] )
        return low;
    // Значение больше максимального в массиве - возвращаем размер массива
    if ( x > A[high] )
        return high + 1;
    while ( low < high ) {
        if ( x < A[mid] ) {  // Элемент в левой части - ищем рекурсивно в левой части
            high = mid;
        } else {
            if ( x > A[mid] ) {  // Элемент в правой части - ищем рекурсивно в правой части
                low = mid + 1;
            } else {
                return mid; // Нашли элемент - возвращаем его индекс
              }
        }
        mid = low + (high - low)/2;
    }
    if ( x <= A[low] ) return low;
    else
        return high;
}

// Бинарный поиск Binary_Search для каждого из элементов массива B в массиве A
int* Search(int *A, int NA, int *B, int NB) {
    int* C = new int[NB];
    int i = 0;  // Индекс для поиска для i-го элемента массива B
    int j = 0;  // Индекс элемента, который будет последним в бинарном поиске
    for ( i = 0; i < NB; ++i ) {
        // Делать поиск каждый раз по массиву целиком - неэффективно!
        // Поэтому делаем почти линейный бинарный поиск по массиву,
        // каждый раз увеличивая шаг в 2 раза и записываем рез-т в массив С
        for ( j = 1; A[j] <= B[i] && j != NA - 1; j = std::min(3*j, NA - 1)) {}
        C[i] = Binary_Search(A, 0, j, B[i]);
    }
    return C;  // Возвращаем результат - массив C
}
int main() {
    int n_a = 0;  // Размер массива А
    cin >> n_a;
    if ( n_a < 1 ) exit(1);  // Размер задан неверно - выходим из программы
    int n_b = 0;
    cin >> n_b;  // Размер массива B
    if ( n_b < 1 ) exit(1);  // Размер задан неверно - выходим из программы
    int* A = new int[n_a];  // Выделяем память под массив А
    for ( int i = 0; i < n_a; ++i ) {
        cin >> A[i];  // Вводим поэлементно массив А
    }
    int* B = new int[n_b];  // Заводим память под массивы B и C
    int* C = new int[n_b];
    for ( int i = 0; i < n_b; ++i ) {
        cin >> B[i];  // Вводим поэлементно массив B
    }
    C = Search(A, n_a, B, n_b);  // Делаем поиск и записываем результат в массив С
    for ( int i = 0; i < n_b; ++i ) {
        cout << C[i] << " ";  // Выводим поэлементно массив С
    }
    cout << endl;  // Переход на новую строку после выполнения программы
    delete[] A;  // Очищаем память из под массивов A, B и C
    delete[] B;
    delete[] C;
    return 0;  // Успех!
}

